# Лабораторная работа №3 «Работа с таблицами»
## Введение
Необходимо спроектировать и разработать на языке C две программы, осуществляющие работу
с таблицами.
### Нотация
* 3а - работа с таблицей в основной памяти
* 3б - работа с таблицей в внешней памяти
### Структура таблицы
Таблица задается следующей структурой:
```C
typedef struct Table {
// указатель на первое пространство ключей
KeySpace1 *ks1;
// указатель на второе пространство ключей
KeySpace2 *ks2;
// максимальный размер области первого пространства ключей
int msize1;
// максимальный размер области второго пространства ключей
int msize2;
// текущее количество элементов в области первого пространства ключей
int csize1;
// текущее количество элементов в области второго пространства ключей
int csize2;
} Table; 
```
### Операции, поддерживаемые таблицей
Должны быть предусмотрены следующие операции:
* Включение нового элемента в таблицу с соблюдением ограничений на уникальность ключей в
соответствующих ключевых пространствах и уникальность
составного ключа (key1, key2);
* Поиск в таблице элемента, заданного составным ключом;
* Удаление из таблицы элемента, заданного составным ключом;
* Поиск в таблице элемента по любому заданному ключу; результатом поиска должна быть копии
всех найденных элементов со значениями ключей;
* Удаление из таблицы всех элементов, заданного ключом в одном из ключевых пространств;
* Вывод содержимого таблицы на экран (или текстовый файл), при этом формат вывода должен
соответствовать структуре элемента таблицы;

## Задачи
### Основные задачи
Необходимо разработать два следующих варианта программы (лабораторные работы 3а и 3б):
* Сама таблица, и информация, относящаяся к элементам таблицы, хранятся в основной памяти.
* Сама таблица, и информация, относящаяся к элементам таблицы, хранятся во внешней памяти (используется двоичный файл произвольного доступа). Описатель таблицы и описатели
пространств ключей считывается из файла (или создаются в первый раз) в начале сеанса работы и записывается в файл в конце сеанса работы. Информация, относящаяся к элементам
таблицы, записывается в файл сразу же при выполнении операции включения в таблицу и в
основной памяти не хранится (возможно за исключением элемента, с которым производится
текущая операция). Все операции выполняются с описателем таблицы и пространств ключей,
размещенными в основной памяти. Все структуры данных модифицируются соответствующим образом (замена указателей на смещение в файле и т.п.). Имя файла вводится по запросу
из программы и хранится в описателе таблицы.
### Дополнительные задачи
* Реализация поиска как итератора одним из возможных способов (например, в виде функции,
которая при каждом вызове возвращает очередной из найденных элементов).
* Аналогично задаче 3б, но все операции выполняются с пространствами ключей, размещенными
во внешней памяти, в основной памяти может храниться только описатель таблицы.
* Аналогично предыдущему заданию, но с реализацией буферизации файловых операций
(можно считывать и записывать по несколько записей).
## Примечания
* Логически законченные части алгоритма решения задачи должны быть оформлены в виде отдельных функций с параметрами. Использование глобальных переменных не допускается.
* Функции для работы с таблицами не должны быть диалоговыми, т. е. они должны принимать все необходимые данные в качестве параметров и возвращать результат работы в виде
соответствующих структур данных и кодов ошибок (исключение: функции вывода таблицы в
стандартный поток вывода или записи файл).
* Диалоговые функции должны использовать описанные выше функции, т. е. должен быть реализован принцип [Model View Controller (MVC)](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).
* Программа должна осуществлять проверку корректности вводимых данных и, в случае ошибок,
выдавать соответствующие сообщения, после чего продолжать работу.
* В случае возникновения ошибочных ситуаций при выполнении операций с таблицами программа должна выводить соответствующие сообщения, после чего продолжать работу.
* Программы, реализующие работу с таблицами, размещенными во внешней памяти, должны использовать модифицированную структуру, определяющую элемент таблицы, в которую включена длина информации и её смещение в файле.
* Программы, реализующие работу с таблицами, размещенными во внешней памяти, должны
для работы с файлами использовать функции fread() и fwrite(), которым в качестве аргумента должна передаваться реальная длина информации.
* Программа должна корректным образом работать с памятью, для проверки необходимо использовать соответствующие программные средства, например: [valgrind](https://www.jetbrains.com/help/clion/memory-profiling-with-valgrind.html), санитайзеры, встроенные
в IDE средства и т.д.

# Вариант №090
Каждый **элемент таблицы** имеет следующую структуру:
```C
typedef struct Item {
// указатель на информацию
char *info;
// ключ элемента из 1-го пространства ключей
char *key1;
// ключ элемента из 2-го пространства ключей
char *key2;
} Item;
```
---
* В таблице не могут присутствовать два элемента с одинаковыми составными ключами (key1,
key2).
---
**Первое пространство ключей** организовано как **просматриваемая таблица, организованная списком**. Каждый элемент таблицы имеет следующую структуру:
```C
typedef struct KeySpace1 {
// ключ элемента
char *key;
// номер версии элемента
int release;
// указатель на информацию
Item *info;
// указатель на следующий элемент
KeySpace1 *next;
} KeySpace1;
```
---
**Второе пространство ключей** организовано как **перемешанная таблица, использующая перемешивание сложением**. Перемешанная таблица организована **вектором**. Каждый элемент таблицы имеет следующую структуру:
```C
typedef struct KeySpace2 {
// признак занятости элемента
int busy;
// ключ элемента
char *key;
// указатель на информацию
Node2 *node;
} KeySpace2;
```
**Указатель на информацию** определяет список элементов с одинаковыми значениями ключей. Элемент списка имеет следующую структуру:
```C
typedef struct Node2 {
// номер версии элемента
int release;
// указатель на информацию
Item *info;
// указатель на следующий элемент
Node2 *next;
} Node2;
```
---
* Максимальный размер массива указателей ограничен величиной msize2, значение которой определяется при инициализации таблицы. Для доступа к элементам таблицы используется двойное хеширование.

---
В обоих пространствах могут находиться несколько элементов с одинаковыми ключами и разными номерами версий (номер версии элемента формируется как порядковый номер элемента в последовательности элементов с одинаковыми ключами, определяемый при включении элемента в таблицу).

В данных пространствах ключей предусмотрены следующие особые операции:
* Поиск в таблице всех версий элемента, заданного ключом, или конкретной (заданной) версии
элемента, также заданного своим ключом; результатом поиска должна быть новая таблица, содержащая найденные элементы.
* Удаление из таблицы всех элементов с заданным ключом или элемента определенной версии, также заданного своим ключом.
